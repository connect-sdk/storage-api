// Code generated by counterfeiter. DO NOT EDIT.
package storagev1fake

import (
	"context"
	"sync"

	"cloud.google.com/go/storage"
	storagev1 "github.com/connect-sdk/storage-api/proto/connect/storage/v1"
)

type FakeStorageObjectHandle struct {
	ACLStub        func() storagev1.StorageACLHandle
	aCLMutex       sync.RWMutex
	aCLArgsForCall []struct {
	}
	aCLReturns struct {
		result1 storagev1.StorageACLHandle
	}
	aCLReturnsOnCall map[int]struct {
		result1 storagev1.StorageACLHandle
	}
	AttrsStub        func(context.Context) (*storage.ObjectAttrs, error)
	attrsMutex       sync.RWMutex
	attrsArgsForCall []struct {
		arg1 context.Context
	}
	attrsReturns struct {
		result1 *storage.ObjectAttrs
		result2 error
	}
	attrsReturnsOnCall map[int]struct {
		result1 *storage.ObjectAttrs
		result2 error
	}
	ComposerFromStub        func(...storagev1.StorageObjectHandle) storagev1.StorageObjectComposer
	composerFromMutex       sync.RWMutex
	composerFromArgsForCall []struct {
		arg1 []storagev1.StorageObjectHandle
	}
	composerFromReturns struct {
		result1 storagev1.StorageObjectComposer
	}
	composerFromReturnsOnCall map[int]struct {
		result1 storagev1.StorageObjectComposer
	}
	CopierFromStub        func(storagev1.StorageObjectHandle) storagev1.StorageObjectCopier
	copierFromMutex       sync.RWMutex
	copierFromArgsForCall []struct {
		arg1 storagev1.StorageObjectHandle
	}
	copierFromReturns struct {
		result1 storagev1.StorageObjectCopier
	}
	copierFromReturnsOnCall map[int]struct {
		result1 storagev1.StorageObjectCopier
	}
	DeleteStub        func(context.Context) error
	deleteMutex       sync.RWMutex
	deleteArgsForCall []struct {
		arg1 context.Context
	}
	deleteReturns struct {
		result1 error
	}
	deleteReturnsOnCall map[int]struct {
		result1 error
	}
	GenerationStub        func(int64) storagev1.StorageObjectHandle
	generationMutex       sync.RWMutex
	generationArgsForCall []struct {
		arg1 int64
	}
	generationReturns struct {
		result1 storagev1.StorageObjectHandle
	}
	generationReturnsOnCall map[int]struct {
		result1 storagev1.StorageObjectHandle
	}
	IfStub        func(storage.Conditions) storagev1.StorageObjectHandle
	ifMutex       sync.RWMutex
	ifArgsForCall []struct {
		arg1 storage.Conditions
	}
	ifReturns struct {
		result1 storagev1.StorageObjectHandle
	}
	ifReturnsOnCall map[int]struct {
		result1 storagev1.StorageObjectHandle
	}
	KeyStub        func([]byte) storagev1.StorageObjectHandle
	keyMutex       sync.RWMutex
	keyArgsForCall []struct {
		arg1 []byte
	}
	keyReturns struct {
		result1 storagev1.StorageObjectHandle
	}
	keyReturnsOnCall map[int]struct {
		result1 storagev1.StorageObjectHandle
	}
	NewRangeReaderStub        func(context.Context, int64, int64) (storagev1.StorageObjectReader, error)
	newRangeReaderMutex       sync.RWMutex
	newRangeReaderArgsForCall []struct {
		arg1 context.Context
		arg2 int64
		arg3 int64
	}
	newRangeReaderReturns struct {
		result1 storagev1.StorageObjectReader
		result2 error
	}
	newRangeReaderReturnsOnCall map[int]struct {
		result1 storagev1.StorageObjectReader
		result2 error
	}
	NewReaderStub        func(context.Context) (storagev1.StorageObjectReader, error)
	newReaderMutex       sync.RWMutex
	newReaderArgsForCall []struct {
		arg1 context.Context
	}
	newReaderReturns struct {
		result1 storagev1.StorageObjectReader
		result2 error
	}
	newReaderReturnsOnCall map[int]struct {
		result1 storagev1.StorageObjectReader
		result2 error
	}
	NewWriterStub        func(context.Context) storagev1.StorageObjectWriter
	newWriterMutex       sync.RWMutex
	newWriterArgsForCall []struct {
		arg1 context.Context
	}
	newWriterReturns struct {
		result1 storagev1.StorageObjectWriter
	}
	newWriterReturnsOnCall map[int]struct {
		result1 storagev1.StorageObjectWriter
	}
	ReadCompressedStub        func(bool) storagev1.StorageObjectHandle
	readCompressedMutex       sync.RWMutex
	readCompressedArgsForCall []struct {
		arg1 bool
	}
	readCompressedReturns struct {
		result1 storagev1.StorageObjectHandle
	}
	readCompressedReturnsOnCall map[int]struct {
		result1 storagev1.StorageObjectHandle
	}
	UpdateStub        func(context.Context, storage.ObjectAttrsToUpdate) (*storage.ObjectAttrs, error)
	updateMutex       sync.RWMutex
	updateArgsForCall []struct {
		arg1 context.Context
		arg2 storage.ObjectAttrsToUpdate
	}
	updateReturns struct {
		result1 *storage.ObjectAttrs
		result2 error
	}
	updateReturnsOnCall map[int]struct {
		result1 *storage.ObjectAttrs
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeStorageObjectHandle) ACL() storagev1.StorageACLHandle {
	fake.aCLMutex.Lock()
	ret, specificReturn := fake.aCLReturnsOnCall[len(fake.aCLArgsForCall)]
	fake.aCLArgsForCall = append(fake.aCLArgsForCall, struct {
	}{})
	stub := fake.ACLStub
	fakeReturns := fake.aCLReturns
	fake.recordInvocation("ACL", []interface{}{})
	fake.aCLMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorageObjectHandle) ACLCallCount() int {
	fake.aCLMutex.RLock()
	defer fake.aCLMutex.RUnlock()
	return len(fake.aCLArgsForCall)
}

func (fake *FakeStorageObjectHandle) ACLCalls(stub func() storagev1.StorageACLHandle) {
	fake.aCLMutex.Lock()
	defer fake.aCLMutex.Unlock()
	fake.ACLStub = stub
}

func (fake *FakeStorageObjectHandle) ACLReturns(result1 storagev1.StorageACLHandle) {
	fake.aCLMutex.Lock()
	defer fake.aCLMutex.Unlock()
	fake.ACLStub = nil
	fake.aCLReturns = struct {
		result1 storagev1.StorageACLHandle
	}{result1}
}

func (fake *FakeStorageObjectHandle) ACLReturnsOnCall(i int, result1 storagev1.StorageACLHandle) {
	fake.aCLMutex.Lock()
	defer fake.aCLMutex.Unlock()
	fake.ACLStub = nil
	if fake.aCLReturnsOnCall == nil {
		fake.aCLReturnsOnCall = make(map[int]struct {
			result1 storagev1.StorageACLHandle
		})
	}
	fake.aCLReturnsOnCall[i] = struct {
		result1 storagev1.StorageACLHandle
	}{result1}
}

func (fake *FakeStorageObjectHandle) Attrs(arg1 context.Context) (*storage.ObjectAttrs, error) {
	fake.attrsMutex.Lock()
	ret, specificReturn := fake.attrsReturnsOnCall[len(fake.attrsArgsForCall)]
	fake.attrsArgsForCall = append(fake.attrsArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.AttrsStub
	fakeReturns := fake.attrsReturns
	fake.recordInvocation("Attrs", []interface{}{arg1})
	fake.attrsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorageObjectHandle) AttrsCallCount() int {
	fake.attrsMutex.RLock()
	defer fake.attrsMutex.RUnlock()
	return len(fake.attrsArgsForCall)
}

func (fake *FakeStorageObjectHandle) AttrsCalls(stub func(context.Context) (*storage.ObjectAttrs, error)) {
	fake.attrsMutex.Lock()
	defer fake.attrsMutex.Unlock()
	fake.AttrsStub = stub
}

func (fake *FakeStorageObjectHandle) AttrsArgsForCall(i int) context.Context {
	fake.attrsMutex.RLock()
	defer fake.attrsMutex.RUnlock()
	argsForCall := fake.attrsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorageObjectHandle) AttrsReturns(result1 *storage.ObjectAttrs, result2 error) {
	fake.attrsMutex.Lock()
	defer fake.attrsMutex.Unlock()
	fake.AttrsStub = nil
	fake.attrsReturns = struct {
		result1 *storage.ObjectAttrs
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageObjectHandle) AttrsReturnsOnCall(i int, result1 *storage.ObjectAttrs, result2 error) {
	fake.attrsMutex.Lock()
	defer fake.attrsMutex.Unlock()
	fake.AttrsStub = nil
	if fake.attrsReturnsOnCall == nil {
		fake.attrsReturnsOnCall = make(map[int]struct {
			result1 *storage.ObjectAttrs
			result2 error
		})
	}
	fake.attrsReturnsOnCall[i] = struct {
		result1 *storage.ObjectAttrs
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageObjectHandle) ComposerFrom(arg1 ...storagev1.StorageObjectHandle) storagev1.StorageObjectComposer {
	fake.composerFromMutex.Lock()
	ret, specificReturn := fake.composerFromReturnsOnCall[len(fake.composerFromArgsForCall)]
	fake.composerFromArgsForCall = append(fake.composerFromArgsForCall, struct {
		arg1 []storagev1.StorageObjectHandle
	}{arg1})
	stub := fake.ComposerFromStub
	fakeReturns := fake.composerFromReturns
	fake.recordInvocation("ComposerFrom", []interface{}{arg1})
	fake.composerFromMutex.Unlock()
	if stub != nil {
		return stub(arg1...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorageObjectHandle) ComposerFromCallCount() int {
	fake.composerFromMutex.RLock()
	defer fake.composerFromMutex.RUnlock()
	return len(fake.composerFromArgsForCall)
}

func (fake *FakeStorageObjectHandle) ComposerFromCalls(stub func(...storagev1.StorageObjectHandle) storagev1.StorageObjectComposer) {
	fake.composerFromMutex.Lock()
	defer fake.composerFromMutex.Unlock()
	fake.ComposerFromStub = stub
}

func (fake *FakeStorageObjectHandle) ComposerFromArgsForCall(i int) []storagev1.StorageObjectHandle {
	fake.composerFromMutex.RLock()
	defer fake.composerFromMutex.RUnlock()
	argsForCall := fake.composerFromArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorageObjectHandle) ComposerFromReturns(result1 storagev1.StorageObjectComposer) {
	fake.composerFromMutex.Lock()
	defer fake.composerFromMutex.Unlock()
	fake.ComposerFromStub = nil
	fake.composerFromReturns = struct {
		result1 storagev1.StorageObjectComposer
	}{result1}
}

func (fake *FakeStorageObjectHandle) ComposerFromReturnsOnCall(i int, result1 storagev1.StorageObjectComposer) {
	fake.composerFromMutex.Lock()
	defer fake.composerFromMutex.Unlock()
	fake.ComposerFromStub = nil
	if fake.composerFromReturnsOnCall == nil {
		fake.composerFromReturnsOnCall = make(map[int]struct {
			result1 storagev1.StorageObjectComposer
		})
	}
	fake.composerFromReturnsOnCall[i] = struct {
		result1 storagev1.StorageObjectComposer
	}{result1}
}

func (fake *FakeStorageObjectHandle) CopierFrom(arg1 storagev1.StorageObjectHandle) storagev1.StorageObjectCopier {
	fake.copierFromMutex.Lock()
	ret, specificReturn := fake.copierFromReturnsOnCall[len(fake.copierFromArgsForCall)]
	fake.copierFromArgsForCall = append(fake.copierFromArgsForCall, struct {
		arg1 storagev1.StorageObjectHandle
	}{arg1})
	stub := fake.CopierFromStub
	fakeReturns := fake.copierFromReturns
	fake.recordInvocation("CopierFrom", []interface{}{arg1})
	fake.copierFromMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorageObjectHandle) CopierFromCallCount() int {
	fake.copierFromMutex.RLock()
	defer fake.copierFromMutex.RUnlock()
	return len(fake.copierFromArgsForCall)
}

func (fake *FakeStorageObjectHandle) CopierFromCalls(stub func(storagev1.StorageObjectHandle) storagev1.StorageObjectCopier) {
	fake.copierFromMutex.Lock()
	defer fake.copierFromMutex.Unlock()
	fake.CopierFromStub = stub
}

func (fake *FakeStorageObjectHandle) CopierFromArgsForCall(i int) storagev1.StorageObjectHandle {
	fake.copierFromMutex.RLock()
	defer fake.copierFromMutex.RUnlock()
	argsForCall := fake.copierFromArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorageObjectHandle) CopierFromReturns(result1 storagev1.StorageObjectCopier) {
	fake.copierFromMutex.Lock()
	defer fake.copierFromMutex.Unlock()
	fake.CopierFromStub = nil
	fake.copierFromReturns = struct {
		result1 storagev1.StorageObjectCopier
	}{result1}
}

func (fake *FakeStorageObjectHandle) CopierFromReturnsOnCall(i int, result1 storagev1.StorageObjectCopier) {
	fake.copierFromMutex.Lock()
	defer fake.copierFromMutex.Unlock()
	fake.CopierFromStub = nil
	if fake.copierFromReturnsOnCall == nil {
		fake.copierFromReturnsOnCall = make(map[int]struct {
			result1 storagev1.StorageObjectCopier
		})
	}
	fake.copierFromReturnsOnCall[i] = struct {
		result1 storagev1.StorageObjectCopier
	}{result1}
}

func (fake *FakeStorageObjectHandle) Delete(arg1 context.Context) error {
	fake.deleteMutex.Lock()
	ret, specificReturn := fake.deleteReturnsOnCall[len(fake.deleteArgsForCall)]
	fake.deleteArgsForCall = append(fake.deleteArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.DeleteStub
	fakeReturns := fake.deleteReturns
	fake.recordInvocation("Delete", []interface{}{arg1})
	fake.deleteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorageObjectHandle) DeleteCallCount() int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return len(fake.deleteArgsForCall)
}

func (fake *FakeStorageObjectHandle) DeleteCalls(stub func(context.Context) error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = stub
}

func (fake *FakeStorageObjectHandle) DeleteArgsForCall(i int) context.Context {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	argsForCall := fake.deleteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorageObjectHandle) DeleteReturns(result1 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	fake.deleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorageObjectHandle) DeleteReturnsOnCall(i int, result1 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	if fake.deleteReturnsOnCall == nil {
		fake.deleteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorageObjectHandle) Generation(arg1 int64) storagev1.StorageObjectHandle {
	fake.generationMutex.Lock()
	ret, specificReturn := fake.generationReturnsOnCall[len(fake.generationArgsForCall)]
	fake.generationArgsForCall = append(fake.generationArgsForCall, struct {
		arg1 int64
	}{arg1})
	stub := fake.GenerationStub
	fakeReturns := fake.generationReturns
	fake.recordInvocation("Generation", []interface{}{arg1})
	fake.generationMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorageObjectHandle) GenerationCallCount() int {
	fake.generationMutex.RLock()
	defer fake.generationMutex.RUnlock()
	return len(fake.generationArgsForCall)
}

func (fake *FakeStorageObjectHandle) GenerationCalls(stub func(int64) storagev1.StorageObjectHandle) {
	fake.generationMutex.Lock()
	defer fake.generationMutex.Unlock()
	fake.GenerationStub = stub
}

func (fake *FakeStorageObjectHandle) GenerationArgsForCall(i int) int64 {
	fake.generationMutex.RLock()
	defer fake.generationMutex.RUnlock()
	argsForCall := fake.generationArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorageObjectHandle) GenerationReturns(result1 storagev1.StorageObjectHandle) {
	fake.generationMutex.Lock()
	defer fake.generationMutex.Unlock()
	fake.GenerationStub = nil
	fake.generationReturns = struct {
		result1 storagev1.StorageObjectHandle
	}{result1}
}

func (fake *FakeStorageObjectHandle) GenerationReturnsOnCall(i int, result1 storagev1.StorageObjectHandle) {
	fake.generationMutex.Lock()
	defer fake.generationMutex.Unlock()
	fake.GenerationStub = nil
	if fake.generationReturnsOnCall == nil {
		fake.generationReturnsOnCall = make(map[int]struct {
			result1 storagev1.StorageObjectHandle
		})
	}
	fake.generationReturnsOnCall[i] = struct {
		result1 storagev1.StorageObjectHandle
	}{result1}
}

func (fake *FakeStorageObjectHandle) If(arg1 storage.Conditions) storagev1.StorageObjectHandle {
	fake.ifMutex.Lock()
	ret, specificReturn := fake.ifReturnsOnCall[len(fake.ifArgsForCall)]
	fake.ifArgsForCall = append(fake.ifArgsForCall, struct {
		arg1 storage.Conditions
	}{arg1})
	stub := fake.IfStub
	fakeReturns := fake.ifReturns
	fake.recordInvocation("If", []interface{}{arg1})
	fake.ifMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorageObjectHandle) IfCallCount() int {
	fake.ifMutex.RLock()
	defer fake.ifMutex.RUnlock()
	return len(fake.ifArgsForCall)
}

func (fake *FakeStorageObjectHandle) IfCalls(stub func(storage.Conditions) storagev1.StorageObjectHandle) {
	fake.ifMutex.Lock()
	defer fake.ifMutex.Unlock()
	fake.IfStub = stub
}

func (fake *FakeStorageObjectHandle) IfArgsForCall(i int) storage.Conditions {
	fake.ifMutex.RLock()
	defer fake.ifMutex.RUnlock()
	argsForCall := fake.ifArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorageObjectHandle) IfReturns(result1 storagev1.StorageObjectHandle) {
	fake.ifMutex.Lock()
	defer fake.ifMutex.Unlock()
	fake.IfStub = nil
	fake.ifReturns = struct {
		result1 storagev1.StorageObjectHandle
	}{result1}
}

func (fake *FakeStorageObjectHandle) IfReturnsOnCall(i int, result1 storagev1.StorageObjectHandle) {
	fake.ifMutex.Lock()
	defer fake.ifMutex.Unlock()
	fake.IfStub = nil
	if fake.ifReturnsOnCall == nil {
		fake.ifReturnsOnCall = make(map[int]struct {
			result1 storagev1.StorageObjectHandle
		})
	}
	fake.ifReturnsOnCall[i] = struct {
		result1 storagev1.StorageObjectHandle
	}{result1}
}

func (fake *FakeStorageObjectHandle) Key(arg1 []byte) storagev1.StorageObjectHandle {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.keyMutex.Lock()
	ret, specificReturn := fake.keyReturnsOnCall[len(fake.keyArgsForCall)]
	fake.keyArgsForCall = append(fake.keyArgsForCall, struct {
		arg1 []byte
	}{arg1Copy})
	stub := fake.KeyStub
	fakeReturns := fake.keyReturns
	fake.recordInvocation("Key", []interface{}{arg1Copy})
	fake.keyMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorageObjectHandle) KeyCallCount() int {
	fake.keyMutex.RLock()
	defer fake.keyMutex.RUnlock()
	return len(fake.keyArgsForCall)
}

func (fake *FakeStorageObjectHandle) KeyCalls(stub func([]byte) storagev1.StorageObjectHandle) {
	fake.keyMutex.Lock()
	defer fake.keyMutex.Unlock()
	fake.KeyStub = stub
}

func (fake *FakeStorageObjectHandle) KeyArgsForCall(i int) []byte {
	fake.keyMutex.RLock()
	defer fake.keyMutex.RUnlock()
	argsForCall := fake.keyArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorageObjectHandle) KeyReturns(result1 storagev1.StorageObjectHandle) {
	fake.keyMutex.Lock()
	defer fake.keyMutex.Unlock()
	fake.KeyStub = nil
	fake.keyReturns = struct {
		result1 storagev1.StorageObjectHandle
	}{result1}
}

func (fake *FakeStorageObjectHandle) KeyReturnsOnCall(i int, result1 storagev1.StorageObjectHandle) {
	fake.keyMutex.Lock()
	defer fake.keyMutex.Unlock()
	fake.KeyStub = nil
	if fake.keyReturnsOnCall == nil {
		fake.keyReturnsOnCall = make(map[int]struct {
			result1 storagev1.StorageObjectHandle
		})
	}
	fake.keyReturnsOnCall[i] = struct {
		result1 storagev1.StorageObjectHandle
	}{result1}
}

func (fake *FakeStorageObjectHandle) NewRangeReader(arg1 context.Context, arg2 int64, arg3 int64) (storagev1.StorageObjectReader, error) {
	fake.newRangeReaderMutex.Lock()
	ret, specificReturn := fake.newRangeReaderReturnsOnCall[len(fake.newRangeReaderArgsForCall)]
	fake.newRangeReaderArgsForCall = append(fake.newRangeReaderArgsForCall, struct {
		arg1 context.Context
		arg2 int64
		arg3 int64
	}{arg1, arg2, arg3})
	stub := fake.NewRangeReaderStub
	fakeReturns := fake.newRangeReaderReturns
	fake.recordInvocation("NewRangeReader", []interface{}{arg1, arg2, arg3})
	fake.newRangeReaderMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorageObjectHandle) NewRangeReaderCallCount() int {
	fake.newRangeReaderMutex.RLock()
	defer fake.newRangeReaderMutex.RUnlock()
	return len(fake.newRangeReaderArgsForCall)
}

func (fake *FakeStorageObjectHandle) NewRangeReaderCalls(stub func(context.Context, int64, int64) (storagev1.StorageObjectReader, error)) {
	fake.newRangeReaderMutex.Lock()
	defer fake.newRangeReaderMutex.Unlock()
	fake.NewRangeReaderStub = stub
}

func (fake *FakeStorageObjectHandle) NewRangeReaderArgsForCall(i int) (context.Context, int64, int64) {
	fake.newRangeReaderMutex.RLock()
	defer fake.newRangeReaderMutex.RUnlock()
	argsForCall := fake.newRangeReaderArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStorageObjectHandle) NewRangeReaderReturns(result1 storagev1.StorageObjectReader, result2 error) {
	fake.newRangeReaderMutex.Lock()
	defer fake.newRangeReaderMutex.Unlock()
	fake.NewRangeReaderStub = nil
	fake.newRangeReaderReturns = struct {
		result1 storagev1.StorageObjectReader
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageObjectHandle) NewRangeReaderReturnsOnCall(i int, result1 storagev1.StorageObjectReader, result2 error) {
	fake.newRangeReaderMutex.Lock()
	defer fake.newRangeReaderMutex.Unlock()
	fake.NewRangeReaderStub = nil
	if fake.newRangeReaderReturnsOnCall == nil {
		fake.newRangeReaderReturnsOnCall = make(map[int]struct {
			result1 storagev1.StorageObjectReader
			result2 error
		})
	}
	fake.newRangeReaderReturnsOnCall[i] = struct {
		result1 storagev1.StorageObjectReader
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageObjectHandle) NewReader(arg1 context.Context) (storagev1.StorageObjectReader, error) {
	fake.newReaderMutex.Lock()
	ret, specificReturn := fake.newReaderReturnsOnCall[len(fake.newReaderArgsForCall)]
	fake.newReaderArgsForCall = append(fake.newReaderArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.NewReaderStub
	fakeReturns := fake.newReaderReturns
	fake.recordInvocation("NewReader", []interface{}{arg1})
	fake.newReaderMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorageObjectHandle) NewReaderCallCount() int {
	fake.newReaderMutex.RLock()
	defer fake.newReaderMutex.RUnlock()
	return len(fake.newReaderArgsForCall)
}

func (fake *FakeStorageObjectHandle) NewReaderCalls(stub func(context.Context) (storagev1.StorageObjectReader, error)) {
	fake.newReaderMutex.Lock()
	defer fake.newReaderMutex.Unlock()
	fake.NewReaderStub = stub
}

func (fake *FakeStorageObjectHandle) NewReaderArgsForCall(i int) context.Context {
	fake.newReaderMutex.RLock()
	defer fake.newReaderMutex.RUnlock()
	argsForCall := fake.newReaderArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorageObjectHandle) NewReaderReturns(result1 storagev1.StorageObjectReader, result2 error) {
	fake.newReaderMutex.Lock()
	defer fake.newReaderMutex.Unlock()
	fake.NewReaderStub = nil
	fake.newReaderReturns = struct {
		result1 storagev1.StorageObjectReader
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageObjectHandle) NewReaderReturnsOnCall(i int, result1 storagev1.StorageObjectReader, result2 error) {
	fake.newReaderMutex.Lock()
	defer fake.newReaderMutex.Unlock()
	fake.NewReaderStub = nil
	if fake.newReaderReturnsOnCall == nil {
		fake.newReaderReturnsOnCall = make(map[int]struct {
			result1 storagev1.StorageObjectReader
			result2 error
		})
	}
	fake.newReaderReturnsOnCall[i] = struct {
		result1 storagev1.StorageObjectReader
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageObjectHandle) NewWriter(arg1 context.Context) storagev1.StorageObjectWriter {
	fake.newWriterMutex.Lock()
	ret, specificReturn := fake.newWriterReturnsOnCall[len(fake.newWriterArgsForCall)]
	fake.newWriterArgsForCall = append(fake.newWriterArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.NewWriterStub
	fakeReturns := fake.newWriterReturns
	fake.recordInvocation("NewWriter", []interface{}{arg1})
	fake.newWriterMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorageObjectHandle) NewWriterCallCount() int {
	fake.newWriterMutex.RLock()
	defer fake.newWriterMutex.RUnlock()
	return len(fake.newWriterArgsForCall)
}

func (fake *FakeStorageObjectHandle) NewWriterCalls(stub func(context.Context) storagev1.StorageObjectWriter) {
	fake.newWriterMutex.Lock()
	defer fake.newWriterMutex.Unlock()
	fake.NewWriterStub = stub
}

func (fake *FakeStorageObjectHandle) NewWriterArgsForCall(i int) context.Context {
	fake.newWriterMutex.RLock()
	defer fake.newWriterMutex.RUnlock()
	argsForCall := fake.newWriterArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorageObjectHandle) NewWriterReturns(result1 storagev1.StorageObjectWriter) {
	fake.newWriterMutex.Lock()
	defer fake.newWriterMutex.Unlock()
	fake.NewWriterStub = nil
	fake.newWriterReturns = struct {
		result1 storagev1.StorageObjectWriter
	}{result1}
}

func (fake *FakeStorageObjectHandle) NewWriterReturnsOnCall(i int, result1 storagev1.StorageObjectWriter) {
	fake.newWriterMutex.Lock()
	defer fake.newWriterMutex.Unlock()
	fake.NewWriterStub = nil
	if fake.newWriterReturnsOnCall == nil {
		fake.newWriterReturnsOnCall = make(map[int]struct {
			result1 storagev1.StorageObjectWriter
		})
	}
	fake.newWriterReturnsOnCall[i] = struct {
		result1 storagev1.StorageObjectWriter
	}{result1}
}

func (fake *FakeStorageObjectHandle) ReadCompressed(arg1 bool) storagev1.StorageObjectHandle {
	fake.readCompressedMutex.Lock()
	ret, specificReturn := fake.readCompressedReturnsOnCall[len(fake.readCompressedArgsForCall)]
	fake.readCompressedArgsForCall = append(fake.readCompressedArgsForCall, struct {
		arg1 bool
	}{arg1})
	stub := fake.ReadCompressedStub
	fakeReturns := fake.readCompressedReturns
	fake.recordInvocation("ReadCompressed", []interface{}{arg1})
	fake.readCompressedMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorageObjectHandle) ReadCompressedCallCount() int {
	fake.readCompressedMutex.RLock()
	defer fake.readCompressedMutex.RUnlock()
	return len(fake.readCompressedArgsForCall)
}

func (fake *FakeStorageObjectHandle) ReadCompressedCalls(stub func(bool) storagev1.StorageObjectHandle) {
	fake.readCompressedMutex.Lock()
	defer fake.readCompressedMutex.Unlock()
	fake.ReadCompressedStub = stub
}

func (fake *FakeStorageObjectHandle) ReadCompressedArgsForCall(i int) bool {
	fake.readCompressedMutex.RLock()
	defer fake.readCompressedMutex.RUnlock()
	argsForCall := fake.readCompressedArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorageObjectHandle) ReadCompressedReturns(result1 storagev1.StorageObjectHandle) {
	fake.readCompressedMutex.Lock()
	defer fake.readCompressedMutex.Unlock()
	fake.ReadCompressedStub = nil
	fake.readCompressedReturns = struct {
		result1 storagev1.StorageObjectHandle
	}{result1}
}

func (fake *FakeStorageObjectHandle) ReadCompressedReturnsOnCall(i int, result1 storagev1.StorageObjectHandle) {
	fake.readCompressedMutex.Lock()
	defer fake.readCompressedMutex.Unlock()
	fake.ReadCompressedStub = nil
	if fake.readCompressedReturnsOnCall == nil {
		fake.readCompressedReturnsOnCall = make(map[int]struct {
			result1 storagev1.StorageObjectHandle
		})
	}
	fake.readCompressedReturnsOnCall[i] = struct {
		result1 storagev1.StorageObjectHandle
	}{result1}
}

func (fake *FakeStorageObjectHandle) Update(arg1 context.Context, arg2 storage.ObjectAttrsToUpdate) (*storage.ObjectAttrs, error) {
	fake.updateMutex.Lock()
	ret, specificReturn := fake.updateReturnsOnCall[len(fake.updateArgsForCall)]
	fake.updateArgsForCall = append(fake.updateArgsForCall, struct {
		arg1 context.Context
		arg2 storage.ObjectAttrsToUpdate
	}{arg1, arg2})
	stub := fake.UpdateStub
	fakeReturns := fake.updateReturns
	fake.recordInvocation("Update", []interface{}{arg1, arg2})
	fake.updateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorageObjectHandle) UpdateCallCount() int {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	return len(fake.updateArgsForCall)
}

func (fake *FakeStorageObjectHandle) UpdateCalls(stub func(context.Context, storage.ObjectAttrsToUpdate) (*storage.ObjectAttrs, error)) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = stub
}

func (fake *FakeStorageObjectHandle) UpdateArgsForCall(i int) (context.Context, storage.ObjectAttrsToUpdate) {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	argsForCall := fake.updateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStorageObjectHandle) UpdateReturns(result1 *storage.ObjectAttrs, result2 error) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = nil
	fake.updateReturns = struct {
		result1 *storage.ObjectAttrs
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageObjectHandle) UpdateReturnsOnCall(i int, result1 *storage.ObjectAttrs, result2 error) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = nil
	if fake.updateReturnsOnCall == nil {
		fake.updateReturnsOnCall = make(map[int]struct {
			result1 *storage.ObjectAttrs
			result2 error
		})
	}
	fake.updateReturnsOnCall[i] = struct {
		result1 *storage.ObjectAttrs
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageObjectHandle) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.aCLMutex.RLock()
	defer fake.aCLMutex.RUnlock()
	fake.attrsMutex.RLock()
	defer fake.attrsMutex.RUnlock()
	fake.composerFromMutex.RLock()
	defer fake.composerFromMutex.RUnlock()
	fake.copierFromMutex.RLock()
	defer fake.copierFromMutex.RUnlock()
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	fake.generationMutex.RLock()
	defer fake.generationMutex.RUnlock()
	fake.ifMutex.RLock()
	defer fake.ifMutex.RUnlock()
	fake.keyMutex.RLock()
	defer fake.keyMutex.RUnlock()
	fake.newRangeReaderMutex.RLock()
	defer fake.newRangeReaderMutex.RUnlock()
	fake.newReaderMutex.RLock()
	defer fake.newReaderMutex.RUnlock()
	fake.newWriterMutex.RLock()
	defer fake.newWriterMutex.RUnlock()
	fake.readCompressedMutex.RLock()
	defer fake.readCompressedMutex.RUnlock()
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeStorageObjectHandle) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ storagev1.StorageObjectHandle = new(FakeStorageObjectHandle)
