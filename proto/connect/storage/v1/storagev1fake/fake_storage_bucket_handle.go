// Code generated by counterfeiter. DO NOT EDIT.
package storagev1fake

import (
	"context"
	"sync"

	"cloud.google.com/go/storage"
	storagev1 "github.com/connect-sdk/storage-api/proto/connect/storage/v1"
)

type FakeStorageBucketHandle struct {
	ACLStub        func() storagev1.StorageACLHandle
	aCLMutex       sync.RWMutex
	aCLArgsForCall []struct {
	}
	aCLReturns struct {
		result1 storagev1.StorageACLHandle
	}
	aCLReturnsOnCall map[int]struct {
		result1 storagev1.StorageACLHandle
	}
	AddNotificationStub        func(context.Context, *storage.Notification) (*storage.Notification, error)
	addNotificationMutex       sync.RWMutex
	addNotificationArgsForCall []struct {
		arg1 context.Context
		arg2 *storage.Notification
	}
	addNotificationReturns struct {
		result1 *storage.Notification
		result2 error
	}
	addNotificationReturnsOnCall map[int]struct {
		result1 *storage.Notification
		result2 error
	}
	AttrsStub        func(context.Context) (*storage.BucketAttrs, error)
	attrsMutex       sync.RWMutex
	attrsArgsForCall []struct {
		arg1 context.Context
	}
	attrsReturns struct {
		result1 *storage.BucketAttrs
		result2 error
	}
	attrsReturnsOnCall map[int]struct {
		result1 *storage.BucketAttrs
		result2 error
	}
	CreateStub        func(context.Context, string, *storage.BucketAttrs) error
	createMutex       sync.RWMutex
	createArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 *storage.BucketAttrs
	}
	createReturns struct {
		result1 error
	}
	createReturnsOnCall map[int]struct {
		result1 error
	}
	DefaultObjectACLStub        func() storagev1.StorageACLHandle
	defaultObjectACLMutex       sync.RWMutex
	defaultObjectACLArgsForCall []struct {
	}
	defaultObjectACLReturns struct {
		result1 storagev1.StorageACLHandle
	}
	defaultObjectACLReturnsOnCall map[int]struct {
		result1 storagev1.StorageACLHandle
	}
	DeleteStub        func(context.Context) error
	deleteMutex       sync.RWMutex
	deleteArgsForCall []struct {
		arg1 context.Context
	}
	deleteReturns struct {
		result1 error
	}
	deleteReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteNotificationStub        func(context.Context, string) error
	deleteNotificationMutex       sync.RWMutex
	deleteNotificationArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	deleteNotificationReturns struct {
		result1 error
	}
	deleteNotificationReturnsOnCall map[int]struct {
		result1 error
	}
	IfStub        func(storage.BucketConditions) storagev1.StorageBucketHandle
	ifMutex       sync.RWMutex
	ifArgsForCall []struct {
		arg1 storage.BucketConditions
	}
	ifReturns struct {
		result1 storagev1.StorageBucketHandle
	}
	ifReturnsOnCall map[int]struct {
		result1 storagev1.StorageBucketHandle
	}
	LockRetentionPolicyStub        func(context.Context) error
	lockRetentionPolicyMutex       sync.RWMutex
	lockRetentionPolicyArgsForCall []struct {
		arg1 context.Context
	}
	lockRetentionPolicyReturns struct {
		result1 error
	}
	lockRetentionPolicyReturnsOnCall map[int]struct {
		result1 error
	}
	NotificationsStub        func(context.Context) (map[string]*storage.Notification, error)
	notificationsMutex       sync.RWMutex
	notificationsArgsForCall []struct {
		arg1 context.Context
	}
	notificationsReturns struct {
		result1 map[string]*storage.Notification
		result2 error
	}
	notificationsReturnsOnCall map[int]struct {
		result1 map[string]*storage.Notification
		result2 error
	}
	ObjectStub        func(string) storagev1.StorageObjectHandle
	objectMutex       sync.RWMutex
	objectArgsForCall []struct {
		arg1 string
	}
	objectReturns struct {
		result1 storagev1.StorageObjectHandle
	}
	objectReturnsOnCall map[int]struct {
		result1 storagev1.StorageObjectHandle
	}
	ObjectsStub        func(context.Context, *storage.Query) storagev1.StorageObjectIterator
	objectsMutex       sync.RWMutex
	objectsArgsForCall []struct {
		arg1 context.Context
		arg2 *storage.Query
	}
	objectsReturns struct {
		result1 storagev1.StorageObjectIterator
	}
	objectsReturnsOnCall map[int]struct {
		result1 storagev1.StorageObjectIterator
	}
	UpdateStub        func(context.Context, storage.BucketAttrsToUpdate) (*storage.BucketAttrs, error)
	updateMutex       sync.RWMutex
	updateArgsForCall []struct {
		arg1 context.Context
		arg2 storage.BucketAttrsToUpdate
	}
	updateReturns struct {
		result1 *storage.BucketAttrs
		result2 error
	}
	updateReturnsOnCall map[int]struct {
		result1 *storage.BucketAttrs
		result2 error
	}
	UserProjectStub        func(string) storagev1.StorageBucketHandle
	userProjectMutex       sync.RWMutex
	userProjectArgsForCall []struct {
		arg1 string
	}
	userProjectReturns struct {
		result1 storagev1.StorageBucketHandle
	}
	userProjectReturnsOnCall map[int]struct {
		result1 storagev1.StorageBucketHandle
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeStorageBucketHandle) ACL() storagev1.StorageACLHandle {
	fake.aCLMutex.Lock()
	ret, specificReturn := fake.aCLReturnsOnCall[len(fake.aCLArgsForCall)]
	fake.aCLArgsForCall = append(fake.aCLArgsForCall, struct {
	}{})
	stub := fake.ACLStub
	fakeReturns := fake.aCLReturns
	fake.recordInvocation("ACL", []interface{}{})
	fake.aCLMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorageBucketHandle) ACLCallCount() int {
	fake.aCLMutex.RLock()
	defer fake.aCLMutex.RUnlock()
	return len(fake.aCLArgsForCall)
}

func (fake *FakeStorageBucketHandle) ACLCalls(stub func() storagev1.StorageACLHandle) {
	fake.aCLMutex.Lock()
	defer fake.aCLMutex.Unlock()
	fake.ACLStub = stub
}

func (fake *FakeStorageBucketHandle) ACLReturns(result1 storagev1.StorageACLHandle) {
	fake.aCLMutex.Lock()
	defer fake.aCLMutex.Unlock()
	fake.ACLStub = nil
	fake.aCLReturns = struct {
		result1 storagev1.StorageACLHandle
	}{result1}
}

func (fake *FakeStorageBucketHandle) ACLReturnsOnCall(i int, result1 storagev1.StorageACLHandle) {
	fake.aCLMutex.Lock()
	defer fake.aCLMutex.Unlock()
	fake.ACLStub = nil
	if fake.aCLReturnsOnCall == nil {
		fake.aCLReturnsOnCall = make(map[int]struct {
			result1 storagev1.StorageACLHandle
		})
	}
	fake.aCLReturnsOnCall[i] = struct {
		result1 storagev1.StorageACLHandle
	}{result1}
}

func (fake *FakeStorageBucketHandle) AddNotification(arg1 context.Context, arg2 *storage.Notification) (*storage.Notification, error) {
	fake.addNotificationMutex.Lock()
	ret, specificReturn := fake.addNotificationReturnsOnCall[len(fake.addNotificationArgsForCall)]
	fake.addNotificationArgsForCall = append(fake.addNotificationArgsForCall, struct {
		arg1 context.Context
		arg2 *storage.Notification
	}{arg1, arg2})
	stub := fake.AddNotificationStub
	fakeReturns := fake.addNotificationReturns
	fake.recordInvocation("AddNotification", []interface{}{arg1, arg2})
	fake.addNotificationMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorageBucketHandle) AddNotificationCallCount() int {
	fake.addNotificationMutex.RLock()
	defer fake.addNotificationMutex.RUnlock()
	return len(fake.addNotificationArgsForCall)
}

func (fake *FakeStorageBucketHandle) AddNotificationCalls(stub func(context.Context, *storage.Notification) (*storage.Notification, error)) {
	fake.addNotificationMutex.Lock()
	defer fake.addNotificationMutex.Unlock()
	fake.AddNotificationStub = stub
}

func (fake *FakeStorageBucketHandle) AddNotificationArgsForCall(i int) (context.Context, *storage.Notification) {
	fake.addNotificationMutex.RLock()
	defer fake.addNotificationMutex.RUnlock()
	argsForCall := fake.addNotificationArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStorageBucketHandle) AddNotificationReturns(result1 *storage.Notification, result2 error) {
	fake.addNotificationMutex.Lock()
	defer fake.addNotificationMutex.Unlock()
	fake.AddNotificationStub = nil
	fake.addNotificationReturns = struct {
		result1 *storage.Notification
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageBucketHandle) AddNotificationReturnsOnCall(i int, result1 *storage.Notification, result2 error) {
	fake.addNotificationMutex.Lock()
	defer fake.addNotificationMutex.Unlock()
	fake.AddNotificationStub = nil
	if fake.addNotificationReturnsOnCall == nil {
		fake.addNotificationReturnsOnCall = make(map[int]struct {
			result1 *storage.Notification
			result2 error
		})
	}
	fake.addNotificationReturnsOnCall[i] = struct {
		result1 *storage.Notification
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageBucketHandle) Attrs(arg1 context.Context) (*storage.BucketAttrs, error) {
	fake.attrsMutex.Lock()
	ret, specificReturn := fake.attrsReturnsOnCall[len(fake.attrsArgsForCall)]
	fake.attrsArgsForCall = append(fake.attrsArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.AttrsStub
	fakeReturns := fake.attrsReturns
	fake.recordInvocation("Attrs", []interface{}{arg1})
	fake.attrsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorageBucketHandle) AttrsCallCount() int {
	fake.attrsMutex.RLock()
	defer fake.attrsMutex.RUnlock()
	return len(fake.attrsArgsForCall)
}

func (fake *FakeStorageBucketHandle) AttrsCalls(stub func(context.Context) (*storage.BucketAttrs, error)) {
	fake.attrsMutex.Lock()
	defer fake.attrsMutex.Unlock()
	fake.AttrsStub = stub
}

func (fake *FakeStorageBucketHandle) AttrsArgsForCall(i int) context.Context {
	fake.attrsMutex.RLock()
	defer fake.attrsMutex.RUnlock()
	argsForCall := fake.attrsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorageBucketHandle) AttrsReturns(result1 *storage.BucketAttrs, result2 error) {
	fake.attrsMutex.Lock()
	defer fake.attrsMutex.Unlock()
	fake.AttrsStub = nil
	fake.attrsReturns = struct {
		result1 *storage.BucketAttrs
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageBucketHandle) AttrsReturnsOnCall(i int, result1 *storage.BucketAttrs, result2 error) {
	fake.attrsMutex.Lock()
	defer fake.attrsMutex.Unlock()
	fake.AttrsStub = nil
	if fake.attrsReturnsOnCall == nil {
		fake.attrsReturnsOnCall = make(map[int]struct {
			result1 *storage.BucketAttrs
			result2 error
		})
	}
	fake.attrsReturnsOnCall[i] = struct {
		result1 *storage.BucketAttrs
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageBucketHandle) Create(arg1 context.Context, arg2 string, arg3 *storage.BucketAttrs) error {
	fake.createMutex.Lock()
	ret, specificReturn := fake.createReturnsOnCall[len(fake.createArgsForCall)]
	fake.createArgsForCall = append(fake.createArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 *storage.BucketAttrs
	}{arg1, arg2, arg3})
	stub := fake.CreateStub
	fakeReturns := fake.createReturns
	fake.recordInvocation("Create", []interface{}{arg1, arg2, arg3})
	fake.createMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorageBucketHandle) CreateCallCount() int {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return len(fake.createArgsForCall)
}

func (fake *FakeStorageBucketHandle) CreateCalls(stub func(context.Context, string, *storage.BucketAttrs) error) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = stub
}

func (fake *FakeStorageBucketHandle) CreateArgsForCall(i int) (context.Context, string, *storage.BucketAttrs) {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	argsForCall := fake.createArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStorageBucketHandle) CreateReturns(result1 error) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = nil
	fake.createReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorageBucketHandle) CreateReturnsOnCall(i int, result1 error) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = nil
	if fake.createReturnsOnCall == nil {
		fake.createReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorageBucketHandle) DefaultObjectACL() storagev1.StorageACLHandle {
	fake.defaultObjectACLMutex.Lock()
	ret, specificReturn := fake.defaultObjectACLReturnsOnCall[len(fake.defaultObjectACLArgsForCall)]
	fake.defaultObjectACLArgsForCall = append(fake.defaultObjectACLArgsForCall, struct {
	}{})
	stub := fake.DefaultObjectACLStub
	fakeReturns := fake.defaultObjectACLReturns
	fake.recordInvocation("DefaultObjectACL", []interface{}{})
	fake.defaultObjectACLMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorageBucketHandle) DefaultObjectACLCallCount() int {
	fake.defaultObjectACLMutex.RLock()
	defer fake.defaultObjectACLMutex.RUnlock()
	return len(fake.defaultObjectACLArgsForCall)
}

func (fake *FakeStorageBucketHandle) DefaultObjectACLCalls(stub func() storagev1.StorageACLHandle) {
	fake.defaultObjectACLMutex.Lock()
	defer fake.defaultObjectACLMutex.Unlock()
	fake.DefaultObjectACLStub = stub
}

func (fake *FakeStorageBucketHandle) DefaultObjectACLReturns(result1 storagev1.StorageACLHandle) {
	fake.defaultObjectACLMutex.Lock()
	defer fake.defaultObjectACLMutex.Unlock()
	fake.DefaultObjectACLStub = nil
	fake.defaultObjectACLReturns = struct {
		result1 storagev1.StorageACLHandle
	}{result1}
}

func (fake *FakeStorageBucketHandle) DefaultObjectACLReturnsOnCall(i int, result1 storagev1.StorageACLHandle) {
	fake.defaultObjectACLMutex.Lock()
	defer fake.defaultObjectACLMutex.Unlock()
	fake.DefaultObjectACLStub = nil
	if fake.defaultObjectACLReturnsOnCall == nil {
		fake.defaultObjectACLReturnsOnCall = make(map[int]struct {
			result1 storagev1.StorageACLHandle
		})
	}
	fake.defaultObjectACLReturnsOnCall[i] = struct {
		result1 storagev1.StorageACLHandle
	}{result1}
}

func (fake *FakeStorageBucketHandle) Delete(arg1 context.Context) error {
	fake.deleteMutex.Lock()
	ret, specificReturn := fake.deleteReturnsOnCall[len(fake.deleteArgsForCall)]
	fake.deleteArgsForCall = append(fake.deleteArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.DeleteStub
	fakeReturns := fake.deleteReturns
	fake.recordInvocation("Delete", []interface{}{arg1})
	fake.deleteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorageBucketHandle) DeleteCallCount() int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return len(fake.deleteArgsForCall)
}

func (fake *FakeStorageBucketHandle) DeleteCalls(stub func(context.Context) error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = stub
}

func (fake *FakeStorageBucketHandle) DeleteArgsForCall(i int) context.Context {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	argsForCall := fake.deleteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorageBucketHandle) DeleteReturns(result1 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	fake.deleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorageBucketHandle) DeleteReturnsOnCall(i int, result1 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	if fake.deleteReturnsOnCall == nil {
		fake.deleteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorageBucketHandle) DeleteNotification(arg1 context.Context, arg2 string) error {
	fake.deleteNotificationMutex.Lock()
	ret, specificReturn := fake.deleteNotificationReturnsOnCall[len(fake.deleteNotificationArgsForCall)]
	fake.deleteNotificationArgsForCall = append(fake.deleteNotificationArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.DeleteNotificationStub
	fakeReturns := fake.deleteNotificationReturns
	fake.recordInvocation("DeleteNotification", []interface{}{arg1, arg2})
	fake.deleteNotificationMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorageBucketHandle) DeleteNotificationCallCount() int {
	fake.deleteNotificationMutex.RLock()
	defer fake.deleteNotificationMutex.RUnlock()
	return len(fake.deleteNotificationArgsForCall)
}

func (fake *FakeStorageBucketHandle) DeleteNotificationCalls(stub func(context.Context, string) error) {
	fake.deleteNotificationMutex.Lock()
	defer fake.deleteNotificationMutex.Unlock()
	fake.DeleteNotificationStub = stub
}

func (fake *FakeStorageBucketHandle) DeleteNotificationArgsForCall(i int) (context.Context, string) {
	fake.deleteNotificationMutex.RLock()
	defer fake.deleteNotificationMutex.RUnlock()
	argsForCall := fake.deleteNotificationArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStorageBucketHandle) DeleteNotificationReturns(result1 error) {
	fake.deleteNotificationMutex.Lock()
	defer fake.deleteNotificationMutex.Unlock()
	fake.DeleteNotificationStub = nil
	fake.deleteNotificationReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorageBucketHandle) DeleteNotificationReturnsOnCall(i int, result1 error) {
	fake.deleteNotificationMutex.Lock()
	defer fake.deleteNotificationMutex.Unlock()
	fake.DeleteNotificationStub = nil
	if fake.deleteNotificationReturnsOnCall == nil {
		fake.deleteNotificationReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteNotificationReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorageBucketHandle) If(arg1 storage.BucketConditions) storagev1.StorageBucketHandle {
	fake.ifMutex.Lock()
	ret, specificReturn := fake.ifReturnsOnCall[len(fake.ifArgsForCall)]
	fake.ifArgsForCall = append(fake.ifArgsForCall, struct {
		arg1 storage.BucketConditions
	}{arg1})
	stub := fake.IfStub
	fakeReturns := fake.ifReturns
	fake.recordInvocation("If", []interface{}{arg1})
	fake.ifMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorageBucketHandle) IfCallCount() int {
	fake.ifMutex.RLock()
	defer fake.ifMutex.RUnlock()
	return len(fake.ifArgsForCall)
}

func (fake *FakeStorageBucketHandle) IfCalls(stub func(storage.BucketConditions) storagev1.StorageBucketHandle) {
	fake.ifMutex.Lock()
	defer fake.ifMutex.Unlock()
	fake.IfStub = stub
}

func (fake *FakeStorageBucketHandle) IfArgsForCall(i int) storage.BucketConditions {
	fake.ifMutex.RLock()
	defer fake.ifMutex.RUnlock()
	argsForCall := fake.ifArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorageBucketHandle) IfReturns(result1 storagev1.StorageBucketHandle) {
	fake.ifMutex.Lock()
	defer fake.ifMutex.Unlock()
	fake.IfStub = nil
	fake.ifReturns = struct {
		result1 storagev1.StorageBucketHandle
	}{result1}
}

func (fake *FakeStorageBucketHandle) IfReturnsOnCall(i int, result1 storagev1.StorageBucketHandle) {
	fake.ifMutex.Lock()
	defer fake.ifMutex.Unlock()
	fake.IfStub = nil
	if fake.ifReturnsOnCall == nil {
		fake.ifReturnsOnCall = make(map[int]struct {
			result1 storagev1.StorageBucketHandle
		})
	}
	fake.ifReturnsOnCall[i] = struct {
		result1 storagev1.StorageBucketHandle
	}{result1}
}

func (fake *FakeStorageBucketHandle) LockRetentionPolicy(arg1 context.Context) error {
	fake.lockRetentionPolicyMutex.Lock()
	ret, specificReturn := fake.lockRetentionPolicyReturnsOnCall[len(fake.lockRetentionPolicyArgsForCall)]
	fake.lockRetentionPolicyArgsForCall = append(fake.lockRetentionPolicyArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.LockRetentionPolicyStub
	fakeReturns := fake.lockRetentionPolicyReturns
	fake.recordInvocation("LockRetentionPolicy", []interface{}{arg1})
	fake.lockRetentionPolicyMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorageBucketHandle) LockRetentionPolicyCallCount() int {
	fake.lockRetentionPolicyMutex.RLock()
	defer fake.lockRetentionPolicyMutex.RUnlock()
	return len(fake.lockRetentionPolicyArgsForCall)
}

func (fake *FakeStorageBucketHandle) LockRetentionPolicyCalls(stub func(context.Context) error) {
	fake.lockRetentionPolicyMutex.Lock()
	defer fake.lockRetentionPolicyMutex.Unlock()
	fake.LockRetentionPolicyStub = stub
}

func (fake *FakeStorageBucketHandle) LockRetentionPolicyArgsForCall(i int) context.Context {
	fake.lockRetentionPolicyMutex.RLock()
	defer fake.lockRetentionPolicyMutex.RUnlock()
	argsForCall := fake.lockRetentionPolicyArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorageBucketHandle) LockRetentionPolicyReturns(result1 error) {
	fake.lockRetentionPolicyMutex.Lock()
	defer fake.lockRetentionPolicyMutex.Unlock()
	fake.LockRetentionPolicyStub = nil
	fake.lockRetentionPolicyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorageBucketHandle) LockRetentionPolicyReturnsOnCall(i int, result1 error) {
	fake.lockRetentionPolicyMutex.Lock()
	defer fake.lockRetentionPolicyMutex.Unlock()
	fake.LockRetentionPolicyStub = nil
	if fake.lockRetentionPolicyReturnsOnCall == nil {
		fake.lockRetentionPolicyReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.lockRetentionPolicyReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorageBucketHandle) Notifications(arg1 context.Context) (map[string]*storage.Notification, error) {
	fake.notificationsMutex.Lock()
	ret, specificReturn := fake.notificationsReturnsOnCall[len(fake.notificationsArgsForCall)]
	fake.notificationsArgsForCall = append(fake.notificationsArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.NotificationsStub
	fakeReturns := fake.notificationsReturns
	fake.recordInvocation("Notifications", []interface{}{arg1})
	fake.notificationsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorageBucketHandle) NotificationsCallCount() int {
	fake.notificationsMutex.RLock()
	defer fake.notificationsMutex.RUnlock()
	return len(fake.notificationsArgsForCall)
}

func (fake *FakeStorageBucketHandle) NotificationsCalls(stub func(context.Context) (map[string]*storage.Notification, error)) {
	fake.notificationsMutex.Lock()
	defer fake.notificationsMutex.Unlock()
	fake.NotificationsStub = stub
}

func (fake *FakeStorageBucketHandle) NotificationsArgsForCall(i int) context.Context {
	fake.notificationsMutex.RLock()
	defer fake.notificationsMutex.RUnlock()
	argsForCall := fake.notificationsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorageBucketHandle) NotificationsReturns(result1 map[string]*storage.Notification, result2 error) {
	fake.notificationsMutex.Lock()
	defer fake.notificationsMutex.Unlock()
	fake.NotificationsStub = nil
	fake.notificationsReturns = struct {
		result1 map[string]*storage.Notification
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageBucketHandle) NotificationsReturnsOnCall(i int, result1 map[string]*storage.Notification, result2 error) {
	fake.notificationsMutex.Lock()
	defer fake.notificationsMutex.Unlock()
	fake.NotificationsStub = nil
	if fake.notificationsReturnsOnCall == nil {
		fake.notificationsReturnsOnCall = make(map[int]struct {
			result1 map[string]*storage.Notification
			result2 error
		})
	}
	fake.notificationsReturnsOnCall[i] = struct {
		result1 map[string]*storage.Notification
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageBucketHandle) Object(arg1 string) storagev1.StorageObjectHandle {
	fake.objectMutex.Lock()
	ret, specificReturn := fake.objectReturnsOnCall[len(fake.objectArgsForCall)]
	fake.objectArgsForCall = append(fake.objectArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ObjectStub
	fakeReturns := fake.objectReturns
	fake.recordInvocation("Object", []interface{}{arg1})
	fake.objectMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorageBucketHandle) ObjectCallCount() int {
	fake.objectMutex.RLock()
	defer fake.objectMutex.RUnlock()
	return len(fake.objectArgsForCall)
}

func (fake *FakeStorageBucketHandle) ObjectCalls(stub func(string) storagev1.StorageObjectHandle) {
	fake.objectMutex.Lock()
	defer fake.objectMutex.Unlock()
	fake.ObjectStub = stub
}

func (fake *FakeStorageBucketHandle) ObjectArgsForCall(i int) string {
	fake.objectMutex.RLock()
	defer fake.objectMutex.RUnlock()
	argsForCall := fake.objectArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorageBucketHandle) ObjectReturns(result1 storagev1.StorageObjectHandle) {
	fake.objectMutex.Lock()
	defer fake.objectMutex.Unlock()
	fake.ObjectStub = nil
	fake.objectReturns = struct {
		result1 storagev1.StorageObjectHandle
	}{result1}
}

func (fake *FakeStorageBucketHandle) ObjectReturnsOnCall(i int, result1 storagev1.StorageObjectHandle) {
	fake.objectMutex.Lock()
	defer fake.objectMutex.Unlock()
	fake.ObjectStub = nil
	if fake.objectReturnsOnCall == nil {
		fake.objectReturnsOnCall = make(map[int]struct {
			result1 storagev1.StorageObjectHandle
		})
	}
	fake.objectReturnsOnCall[i] = struct {
		result1 storagev1.StorageObjectHandle
	}{result1}
}

func (fake *FakeStorageBucketHandle) Objects(arg1 context.Context, arg2 *storage.Query) storagev1.StorageObjectIterator {
	fake.objectsMutex.Lock()
	ret, specificReturn := fake.objectsReturnsOnCall[len(fake.objectsArgsForCall)]
	fake.objectsArgsForCall = append(fake.objectsArgsForCall, struct {
		arg1 context.Context
		arg2 *storage.Query
	}{arg1, arg2})
	stub := fake.ObjectsStub
	fakeReturns := fake.objectsReturns
	fake.recordInvocation("Objects", []interface{}{arg1, arg2})
	fake.objectsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorageBucketHandle) ObjectsCallCount() int {
	fake.objectsMutex.RLock()
	defer fake.objectsMutex.RUnlock()
	return len(fake.objectsArgsForCall)
}

func (fake *FakeStorageBucketHandle) ObjectsCalls(stub func(context.Context, *storage.Query) storagev1.StorageObjectIterator) {
	fake.objectsMutex.Lock()
	defer fake.objectsMutex.Unlock()
	fake.ObjectsStub = stub
}

func (fake *FakeStorageBucketHandle) ObjectsArgsForCall(i int) (context.Context, *storage.Query) {
	fake.objectsMutex.RLock()
	defer fake.objectsMutex.RUnlock()
	argsForCall := fake.objectsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStorageBucketHandle) ObjectsReturns(result1 storagev1.StorageObjectIterator) {
	fake.objectsMutex.Lock()
	defer fake.objectsMutex.Unlock()
	fake.ObjectsStub = nil
	fake.objectsReturns = struct {
		result1 storagev1.StorageObjectIterator
	}{result1}
}

func (fake *FakeStorageBucketHandle) ObjectsReturnsOnCall(i int, result1 storagev1.StorageObjectIterator) {
	fake.objectsMutex.Lock()
	defer fake.objectsMutex.Unlock()
	fake.ObjectsStub = nil
	if fake.objectsReturnsOnCall == nil {
		fake.objectsReturnsOnCall = make(map[int]struct {
			result1 storagev1.StorageObjectIterator
		})
	}
	fake.objectsReturnsOnCall[i] = struct {
		result1 storagev1.StorageObjectIterator
	}{result1}
}

func (fake *FakeStorageBucketHandle) Update(arg1 context.Context, arg2 storage.BucketAttrsToUpdate) (*storage.BucketAttrs, error) {
	fake.updateMutex.Lock()
	ret, specificReturn := fake.updateReturnsOnCall[len(fake.updateArgsForCall)]
	fake.updateArgsForCall = append(fake.updateArgsForCall, struct {
		arg1 context.Context
		arg2 storage.BucketAttrsToUpdate
	}{arg1, arg2})
	stub := fake.UpdateStub
	fakeReturns := fake.updateReturns
	fake.recordInvocation("Update", []interface{}{arg1, arg2})
	fake.updateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorageBucketHandle) UpdateCallCount() int {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	return len(fake.updateArgsForCall)
}

func (fake *FakeStorageBucketHandle) UpdateCalls(stub func(context.Context, storage.BucketAttrsToUpdate) (*storage.BucketAttrs, error)) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = stub
}

func (fake *FakeStorageBucketHandle) UpdateArgsForCall(i int) (context.Context, storage.BucketAttrsToUpdate) {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	argsForCall := fake.updateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStorageBucketHandle) UpdateReturns(result1 *storage.BucketAttrs, result2 error) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = nil
	fake.updateReturns = struct {
		result1 *storage.BucketAttrs
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageBucketHandle) UpdateReturnsOnCall(i int, result1 *storage.BucketAttrs, result2 error) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = nil
	if fake.updateReturnsOnCall == nil {
		fake.updateReturnsOnCall = make(map[int]struct {
			result1 *storage.BucketAttrs
			result2 error
		})
	}
	fake.updateReturnsOnCall[i] = struct {
		result1 *storage.BucketAttrs
		result2 error
	}{result1, result2}
}

func (fake *FakeStorageBucketHandle) UserProject(arg1 string) storagev1.StorageBucketHandle {
	fake.userProjectMutex.Lock()
	ret, specificReturn := fake.userProjectReturnsOnCall[len(fake.userProjectArgsForCall)]
	fake.userProjectArgsForCall = append(fake.userProjectArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.UserProjectStub
	fakeReturns := fake.userProjectReturns
	fake.recordInvocation("UserProject", []interface{}{arg1})
	fake.userProjectMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorageBucketHandle) UserProjectCallCount() int {
	fake.userProjectMutex.RLock()
	defer fake.userProjectMutex.RUnlock()
	return len(fake.userProjectArgsForCall)
}

func (fake *FakeStorageBucketHandle) UserProjectCalls(stub func(string) storagev1.StorageBucketHandle) {
	fake.userProjectMutex.Lock()
	defer fake.userProjectMutex.Unlock()
	fake.UserProjectStub = stub
}

func (fake *FakeStorageBucketHandle) UserProjectArgsForCall(i int) string {
	fake.userProjectMutex.RLock()
	defer fake.userProjectMutex.RUnlock()
	argsForCall := fake.userProjectArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorageBucketHandle) UserProjectReturns(result1 storagev1.StorageBucketHandle) {
	fake.userProjectMutex.Lock()
	defer fake.userProjectMutex.Unlock()
	fake.UserProjectStub = nil
	fake.userProjectReturns = struct {
		result1 storagev1.StorageBucketHandle
	}{result1}
}

func (fake *FakeStorageBucketHandle) UserProjectReturnsOnCall(i int, result1 storagev1.StorageBucketHandle) {
	fake.userProjectMutex.Lock()
	defer fake.userProjectMutex.Unlock()
	fake.UserProjectStub = nil
	if fake.userProjectReturnsOnCall == nil {
		fake.userProjectReturnsOnCall = make(map[int]struct {
			result1 storagev1.StorageBucketHandle
		})
	}
	fake.userProjectReturnsOnCall[i] = struct {
		result1 storagev1.StorageBucketHandle
	}{result1}
}

func (fake *FakeStorageBucketHandle) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.aCLMutex.RLock()
	defer fake.aCLMutex.RUnlock()
	fake.addNotificationMutex.RLock()
	defer fake.addNotificationMutex.RUnlock()
	fake.attrsMutex.RLock()
	defer fake.attrsMutex.RUnlock()
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	fake.defaultObjectACLMutex.RLock()
	defer fake.defaultObjectACLMutex.RUnlock()
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	fake.deleteNotificationMutex.RLock()
	defer fake.deleteNotificationMutex.RUnlock()
	fake.ifMutex.RLock()
	defer fake.ifMutex.RUnlock()
	fake.lockRetentionPolicyMutex.RLock()
	defer fake.lockRetentionPolicyMutex.RUnlock()
	fake.notificationsMutex.RLock()
	defer fake.notificationsMutex.RUnlock()
	fake.objectMutex.RLock()
	defer fake.objectMutex.RUnlock()
	fake.objectsMutex.RLock()
	defer fake.objectsMutex.RUnlock()
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	fake.userProjectMutex.RLock()
	defer fake.userProjectMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeStorageBucketHandle) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ storagev1.StorageBucketHandle = new(FakeStorageBucketHandle)
